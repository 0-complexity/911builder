#!/bin/bash
MOBO=`sudo dmidecode -t 2 | awk '/Product Name:/{print $3}'`
source /run/net-*.conf

# if called as ctrlinstall, source cmdline, source config
eval $( cat /proc/cmdline )

if [ "$install" = "" ] ; then
	# new variables to fill in :
	HOSTNAME=BE-LOC-4-ctrl-01
	DOMAIN=BE-LOC-4
	NETBASE=10.12
	NETLSB=1
	MASK=24

	MGMT=0
	MGMTVLAN=2311

	UNTAG=1

	STOR=2
	STORVLAN=2315

	PUBIP=185.69.166.21
	PUBMASK=24
	PUBGW=185.69.166.1
	PUBVLAN=2312
else
	source ${install}
fi

MGMTIP=${NETBASE}.${MGMT}.${NETLSB}
UNTAGIP=${NETBASE}.${UNTAG}.${NETLSB}
STORIP=${NETBASE}.${STOR}.${NETLSB}

# OSIMAGE="ubuntu-16.04.3-20171028.tgz"
OSIMAGE="ubuntu-16.04.3-20171130.tgz"

case "$MOBO" in
   G1SCN-B) # Gooxi Controller node
	BONDIFACES=('enp4s0')
	MGMT=('enp3s0')
	DISKS=( sda sdb )
	;;
   *)
	# some reasonable defaults ;-)
	BONDIFACES=( $DEVICE )
	MGMT=('ovs' '2311')
	DISKS=( sda sdb )
	;;
esac

function zappit(){
    ## zappitall
    ## first, zero out evt fs headers from partitions
    parts=`ls /dev/disk/by-id/ | awk '/part/&&!/wwn/{print}'`
    for i in $parts ; do
        dd if=/dev/zero of=/dev/disk/by-id/${i} bs=1M count=100 &
    done
    wait
    sync

    # same for md devices that could contain an fs
    parts=`ls /dev/disk/by-id/ | awk '/part/&&!/wwn/{print}'`
    mds=`mdadm --detail --scan | awk '/ARRAY/{print $2}'`
    for i in $mds ; do
        dd if=/dev/zero of=$i bs=1M count=100 &
    done
    wait
    sync

    # now stop evt raids
    mdadm --stop --scan
    # erase evt superblocks from md partitions
	echo $parts
    for i in $parts ; do
        mdadm --zero-superblock --force /dev/disk/by-id/${i}
    done
    # we should need :apt-get install gdisk but it's on the rescue of OVH
    # Now we can drop all partition tables
    disks=`ls /dev/disk/by-id/ | awk  '/scsi|ata/{gsub(/\-part.*/,"");print}'|uniq`
    for i in $disks ; do
        # destruct, destroy, obliterate
        SIZE=`blockdev --getsz /dev/disk/by-id/${i}`
        dd if=/dev/zero seek=$(($SIZE - 1024)) bs=512 count=1024 of=/dev/disk/by-id/${i}
        dd if=/dev/zero of=/dev/disk/by-id/${i} bs=1M count=10 && sync
        echo -e 'x\nz\ny\ny\n' | gdisk /dev/disk/by-id/${i}
		udevadm settle
        partprobe /dev/disk/by-id/${i}
	done
    ##
    mdadm --stop --scan
    if ! [ -z "`ls /dev/disk/by-id/ | grep part`" ] ; then
        echo not everything is cleared
        exit 1
    fi
}

function genpartbios(){
    mdadm --stop --scan
	if [ ${#DISKSS[@]} -eq 1 ] ; then
		parted /dev/${DISKS[0]} -s mklabel gpt \
			mkpart bios ext2 1 8M \
			mkpart swap linux-swap 8M 8G \
			mkpart boot ext2 8G 10G \
			mkpart root ext2 10G 100% \
			set 1 bios_grub on set 2 raid on set 4 raid on
    else
		parted /dev/${DISKS[0]} -s mklabel gpt \
			mkpart bios ext2 1 8M \
			mkpart boot ext2 8G 10G \
			mkpart swap linux-swap 8M 8G \
			mkpart root ext2 10G 100% \
			set 1 bios_grub on set 2 raid on set 4 raid on

		parted /dev/${DISKS[1]} -s mklabel gpt \
			mkpart bios ext2 1 8M \
			mkpart boot ext2 8G 10G \
			mkpart swap linux-swap 8M 8G \
			mkpart root ext2 10G 100% \
			set 1 bios_grub on set 2 raid on set 4 raid on
	fi
    # need to sleep here a bit for udev to settle
	udevadm settle
    sleep 2
    mdadm --stop --scan
}

function prepmounts(){
    # prepare /boot
    yes | mdadm --create /dev/md0 -l1 -n2 /dev/${DISKS[0]}2 /dev/${DISKS[1]}2 --force
    sysctl -w dev.raid.speed_limit_max=10
    sysctl -w dev.raid.speed_limit_min=10
    mkfs.ext4 -L BOOT /dev/md0

    # prepare root partition
    yes | mdadm --create /dev/md1 -l1 -n2 /dev/${DISKS[0]}4 /dev/${DISKS[1]}4 --force
	mkfs.ext4 /dev/md1 -E lazy_itable_init=1

    # mount it
	mount /dev/md1 /mnt

    mkdir /mnt/boot
    mount /dev/md0 /mnt/boot
}

function prepmountssingle(){
    # prepare /boot
    yes | mdadm --create /dev/md0 -l1 -n2 /dev/${DISKS[0]}2 missing --force
    sysctl -w dev.raid.speed_limit_max=10
    sysctl -w dev.raid.speed_limit_min=10
    mkfs.ext4 -L BOOT /dev/md0

    # prepare root partition
    yes | mdadm --create /dev/md1 -l1 -n2 /dev/${DISKS[0]}4 missing --force
	mkfs.ext4 /dev/md1 -E lazy_itable_init=1

    # mount it
	mount /dev/md1 /mnt

    mkdir /mnt/boot
    mount /dev/md0 /mnt/boot
}

# TODO errcheck here
function untarit(){
	if [ "$OURFILESERVER" = "LOCAL" ]; then
		# we're on our own, no network
		mkdir -p /root/USB
		mount -r -L GIGINSTALL /root/USB
		[ $? -ne 0 ] && echo "OOPS: No USB and no fullroot, bailing" && exit 1
		# and untar it
		tar --numeric-owner -zxf /root/USB/${OSIMAGE} -C /mnt
	else
		OURFILESERVER="${OURFILESERVER:-$fullroot}"
		# INSTALL
		URL="${OURFILESERVER}/${OSIMAGE}"
		# get the 'image' and pour it in the mountpoint
		wget -qO - $URL | tar --numeric-owner -zxf - -C /mnt
		[ $? -ne 0 ] && echo "OOPS: can't get \"$URL\"" && exit 1
	fi
}

function findXEifaces(){
    # we're looking for fast nics
    IFACES=""
    for i in /sys/class/net/* ; do
        if ethtool ${i##*/}  2> /dev/null | grep -E '10000|40000' &>/dev/null ; then
            IFACES=${IFACES}" ${i##*/}"
        fi
    done
    echo ${IFACES:-eth0 eth1}

}

function findGEifaces(){
    # we're looking for fast nics
    IFACES=""
    for i in /sys/class/net/* ; do
        if ethtool ${i##*/}  2> /dev/null | grep -E '1000 ' &>/dev/null ; then
            IFACES=${IFACES}" ${i##*/}"
        fi
    done
    echo ${IFACES:-eth0 eth1}

}

function mgmtiface(){
	local IFC ADDR GATEWAY
	IFC=$1 ; shift
	ADDR=$1
	[ ${NETLSB} -ne 1 ] && GATEWAY="  gateway ${NETBASE}.${MGMT}.1"
    cat << EOF > /mnt/etc/network/interfaces.d/mgmt.conf
### ${IFC}
auto ${IFC}
iface ${IFC} inet static
  address ${ADDR}/24
  ${GATEWAY}
  pre-up ovs-vsctl --may-exist add-br mgmt
  pre-up ovs-vsctl --may-exist add-port mgmt ${IFC}
EOF
}

function storbr(){
    cat << EOF > /mnt/etc/network/interfaces.d/storage.conf
### storage
auto storage
iface storage inet manual
  pre-up ovs-vsctl --may-exist add-br storage
  pre-up ovs-vsctl --may-exist add-br backplane1
  pre-up ovs-vsctl --may-exist add-port backplane1 bkpln2stor tag=${STORVLAN} -- set Interface bkpln2stor type=patch options:peer=stor2bkpln
  pre-up ovs-vsctl --may-exist add-port storage stor2bkpln -- set Interface stor2bkpln type=patch options:peer=bkpln2stor
EOF
}

function pubiface(){
    cat << EOF > /mnt/etc/network/interfaces.d/public.conf
### public
auto public
iface public inet static
  address ${PUBIP}/${PUBMASK}
  gateway ${PUBGW}
  pre-up ovs-vsctl --may-exist add-br backplane1
  pre-up ovs-vsctl add-port backplane1 public tag=${PUBVLAN} -- set Interface public type=internal
EOF
}

function prepsys(){
    echo $AYSHOSTNAME > /mnt/etc/hostname
    cat << EOF > /mnt/etc/network/interfaces
# The loopback interface
# Interfaces that comes with Debian Potato does not like to see
# "auto" option before "iface" for the first device specified.
iface lo inet loopback
auto lo
source /etc/network/interfaces.d/*conf
EOF

if [ ${#BONDIFACES[@]} -gt 1 ] ; then
  cat << EOF > /mnt/etc/network/interfaces.d/Backplane1.conf
### backplane1
auto backplane1
iface backplane1 inet static
  address ${UNTAGIP}/${MASK}
EOF
  for iface in ${BONDIFACES[@]} ; do
	 echo "  pre-up ip l set ${iface} up " >> /mnt/etc/network/interfaces.d/Backplane1.conf
	 echo "  pre-up sysctl -w net.ipv6.conf.${iface}.disable_ipv6=1"  >> /mnt/etc/network/interfaces.d/Backplane1.conf
  done
  echo "  pre-up ovs-vsctl --may-exist add-br backplane1"  >> /mnt/etc/network/interfaces.d/Backplane1.conf
  echo "  pre-up ovs-vsctl --may-exist add-bond backplane1 bond-backplane1 ${BONDIFACES[@]} bond_mode=balance-tcp lacp=active"  >> /mnt/etc/network/interfaces.d/Backplane1.conf
  # and mgmt iface =
  mgmtiface ${MGMT[0]} ${MGMTIP}

else
   cat << EOF > /mnt/etc/network/interfaces.d/Backplane1.conf
### backplane1
auto backplane1
iface backplane1 inet static
  address ${UNTAGIP}/${MASK}
  pre-up ovs-vsctl --may-exist add-br backplane1
  pre-up ovs-vsctl --may-exist add-port backplane1 ${BONDIFACES[0]}
  pre-up ip l set ${BONDIFACES[0]} up
  pre-up sysctl -w net.ipv6.conf.${BONDIFACES[0]}.disable_ipv6=1
EOF
  mgmtiface ${MGMT[0]} ${MGMTIP}
  pubiface
  storbr
fi

# Also, to make glibc happy, add hostname to /etc/hosts
    cat << EOF > /mnt/etc/hosts
127.0.0.1   localhost $AYSHOSTNAME

# The following lines are desirable for IPv6 capable hosts
::1     localhost ip6-localhost ip6-loopback $AYSHOSTNAME
ff02::1 ip6-allnodes
ff02::2 ip6-allrouters
EOF

# Also remove OpenVSwitch initial db
rm -f /mnt/etc/openvswitch/*
# same for persitent net-rules
cat << EOF > /mnt/etc/udev/rules.d/70-persistent-net.rules
# This file was automatically generated by the /lib/udev/write_net_rules
# program, run by the persistent-net-generator.rules rules file.
#
# You can modify it, as long as you keep each rule on a single
# line, and change only the value of the NAME= key.

EOF

}

function installgrub(){
    cat << EOF > /mnt/rungrub
#!/bin/bash
echo "" > /etc/mdadm/mdadm.conf
update-initramfs -c -k all
rm -f /boot/grub/grub.cfg
grub-install --force /dev/${DISKS[0]}
grub-install --force /dev/${DISKS[1]} &> /dev/null
sed -e '/Waiting for/ {n; s/sleep.*/sleep 5/g}' -e '/up to/{n ; s/sleep.*/sleep 5/g}' /etc/init/failsafe.conf > /tmp/fs.conf
mv -f /tmp/fs.conf /etc/init/failsafe.conf
echo "net.core.default_qdisc=fq" >> /etc/sysctl.conf

update-grub
rm -f rungrub
EOF

    chmod 755 /mnt/rungrub
    ./init-chroot /mnt /rungrub
}


function createswaps(){
    # dont forget to create swapsig
    if [ ${#DISKS[@]} -eq 1 ] ; then
        mkswap /dev/${DISKS[0]}3
    else
        mkswap /dev/${DISKS[0]}3
        mkswap /dev/${DISKS[1]}3
    fi
}

function mkfstab(){
    # generate fstab
    BOOTUUID=`blkid -o value /dev/md0 -s UUID`
    ROOTUUID=`blkid -o value /dev/md1 -s UUID`
    SWAPUUID=`blkid -o value /dev/${DISKS[0]}3 -s UUID`

    cat <<EOF > /mnt/etc/fstab
# <file system> <mount point>   <type>  <options>       <dump>  <pass>
proc            /proc   proc    defaults                0       0
sysfs           /sys    sysfs   defaults                0       0
devtmpfs        /dev    devtmpfs        rw      0       0
UUID=${ROOTUUID}  /     ext4 defaults,discard,data=ordered 0 0
UUID=${BOOTUUID}  /boot ext4 defaults 0 0
UUID=${SWAPUUID} none swap sw 0 0
EOF
    if [ ${#DISKS[@]} -eq 2 ] ; then
    SWAPUUID=`blkid -o value /dev/${DISKS[1]}3 -s UUID`
    cat <<EOF >> /mnt/etc/fstab
UUID=${SWAPUUID} none swap sw 0 0
EOF
	fi
}


# PXE created environment
eval $( cat /proc/cmdline ) &> /dev/null
AYSHOSTNAME=${HOSTNAME}.${DNSDOMAIN}
OURFILESERVER=${fullroot:-LOCAL}

# to use findifaces, you need to create an empty BONDIFACES array
if [ ${#BONDIFACES[@]} -eq 0 ] ; then
	BONDIFACES=( $(findifaces) )
fi
# set hostname to some default
hostname ${AYSHOSTNAME}
export HOSTNAME=${AYSHOSTNAME}

# run functions
if [ ${#DISKS[@]} -eq 0 ] ; then
# findssds
  :
fi
zappit
genpartbios
if [ ${#DISKS[@]} -eq 1 ] ; then
    prepmountssingle
else
    prepmounts
fi
untarit
prepsys
createswaps
mkfstab
installgrub

# get pubkey autorized_keys
if [ ! "${fullroot}" = "" ]; then
	wget ${fullroot}/pubkey -O - >> /mnt/root/.ssh/authorized_keys
fi

# umount the stuff
umount /mnt/boot /mnt

# that should do it

echo "All done"
